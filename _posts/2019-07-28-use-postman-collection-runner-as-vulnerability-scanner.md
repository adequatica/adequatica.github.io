---
layout: post
title: "Use Postman Collection Runner as Vulnerability Scanner"
date: 2019-07-28 08:42:26 +0300
tags: postman security testing xss
---

Sometimes, as a test engineer, you need to perform a brief security testing under your application.

Of course, if you have enough time and relevant skills you will use [Burp Scanner](https://portswigger.net/burp/documentation/desktop/automated-scanning) for searching [XSS vulnerabilities](https://portswigger.net/web-security/cross-site-scripting) in your API. But if it is needed to get trivial and really fast feedback you can choose something simpler. And [Postman](https://www.postman.com/) is almost perfectly suited for this task.

Let’s assume that you already know the endpoint you want to scan. For testing purposes, let’s take the example of [Google Books API](https://developers.google.com/books/docs/v1/getting_started) because it’s open (I do not want to explore it, just show how it works):

```
https://www.googleapis.com/books/v1/volumes?q=isbn:1788624785
```

In the selected API endpoint, you need to determine a part for application’s «vectors of attack»:

```
{% raw %}https://www.googleapis.com/books/v1/volumes?q={{vector}}{% endraw %}
```

Then you need a [Postman Collection Runner](https://learning.postman.com/docs/collections/running-collections/intro-to-collection-runs/) and a data file full of XSS vectors.

In the Postman Collection Runner, you can import files in JSON or CSV format, which lines of data will be [iterated](https://blog.postman.com/looping-through-a-data-file-in-the-postman-collection-runner/) (for more info, read «[Working with data files](https://learning.postman.com/docs/collections/running-collections/working-with-data-files/)»).

CSV is more simple, so I prefer it and I use a list of «666 lines of XSS vectors, suitable for attacking an API» with a few lines of my own additions.

Unfortunately, Postman does not work with double quotes and extra commas in selected files, so the CSV data should be sanitized from these characters. It dramatically reduces a variety of test cases, but it is the fee for using a tool that is not quite appropriate.

At least you need to write a test to catch undesirable behavior. Due to many reasons: hard to catch stored XSS in response (in case of 200 response code), exceeding rate limits (in case of 429 or 403 response codes), or proper backend reaction to invalid request (in case of 400 response code), let’s expect only for [Internal Server Error](https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/500). In terms of [Postman Test scripts](https://learning.postman.com/docs/writing-scripts/test-scripts/), it will look like this:

```
pm.test("Status code is not 500", function () {
  pm.response.to.have.not.status(500);
});
```

![Variable {vector} references to the first line in of CSV file](/assets/2019-07-28/01-variable-vector.png)

_Fig. 1. Variable {vector} references to the first line in of CSV file_

Now run the collection:

1. Open Collection Runner;
2. Select the prepared data file;
3. Click [Run].

![Data file type will be chosen automatically](/assets/2019-07-28/02-data-file-type.png)

_Fig. 2. Data file type will be chosen automatically_

If you get 500 of any request, you can definitely submit an issue.

![In this example everything is OK](/assets/2019-07-28/03-run-summary.png)

_Fig. 3. In this example everything is OK_

Try it yourself, with [the sample of Postman Collection and CSV files](https://github.com/adequatica/postman-xss-scanner).

Copy @ [Medium](https://adequatica.medium.com/use-postman-collection-runner-as-vulnerability-scanner-aff7471c94fb)
